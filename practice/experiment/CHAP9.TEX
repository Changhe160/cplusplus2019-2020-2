\chapter{继承与多态}
\thispagestyle{empty}
\setlength{\fboxrule}{0pt}\setlength{\fboxsep}{0cm}
\noindent\color{blueblack}\shadowbox{
\begin{tabular}{|p{13.8cm}|}\arrayrulecolor{darkblue}\hline
\rowcolor{darkblue} \hei\textcolor{white}{实验目的}\\\hline
\rowcolor{lightblue}~~~~~~~~\kai\textcolor{darkblue}{继承与派生是面向对象的特性，是面向对象程序设计模拟客观世界的手段之一，本实验的内容包括介绍基础类的派生关系，通过实验要求掌握以下内容。}\\
\rowcolor{lightblue}~~~~~~~~\kai\textcolor{darkblue}{1. 掌握类继承与派生关系以及实现方法，理解类的层次结构。}\\
\rowcolor{lightblue}~~~~~~~~\kai\textcolor{darkblue}{2. 掌握派生类构造函数初始化基类成员和对象成员的方法。}\\
\rowcolor{lightblue}~~~~~~~~\kai\textcolor{darkblue}{3. 掌握赋值兼容原则，掌握派生类的复制构造函数和赋值运算符的定义。}\\
\rowcolor{lightblue}~~~~~~~~\kai\textcolor{darkblue}{4. 在掌握继承与派生关系的基础上，进一步理解虚函数与多态性的关系，实现运行时的多态。}\\
\rowcolor{lightblue}~~~~~~~~\kai\textcolor{darkblue}{5. 学会定义和使用纯虚函数。}\\
\end{tabular}}\color{black}\\
\\
%\noindent\color{blueblack}\shadowbox{
%\begin{tabular}{|p{13.8cm}|}\arrayrulecolor{darkblue}\hline
%\rowcolor{darkblue} \hei\textcolor{white}{实验环境}\\\hline
%\rowcolor{lightblue}~~~~~~~~\kai\textcolor{darkblue}{1. Windows XP 以上操作系统。}\\
%\rowcolor{lightblue}~~~~~~~~\kai\textcolor{darkblue}{2. Visual Studio 2015 语言环境。}\\
%\rowcolor{lightblue}~~~~~~~~\kai\textcolor{darkblue}{3. 每人一台PC机。}\\
%\end{tabular}}\color{black}
\setlength{\fboxrule}{1pt}\setlength{\fboxsep}{4pt}
\section*{实验内容}

\section*{实验9.1\quad 定义一个继承与派生关系的类体系}
\addcontentsline{toc}{section}{实验9.2\quad 定义一个继承与派生关系的类体系}
定义一个继承与派生关系的类体系，在派生类中访问基类成员。先定义一个点类，数据成员为x，y坐标；以点为基类派生一个圆类，增加表示半径的数据成员；采用组合与包含的方式定义一个线段类，以两个点类对象作数据成员。\\
\noindent 【要求】
\begin{enumerate}
  \item 主要考察派生类的拷贝成员的控制，包括构造与析构，复制、赋值、移动等操作；
  \item 建立工程，录入上述程序，改变数据实验之；
  \item 修改Point类的数据成员m\_x,m\_y的访问权限为private，再运行，结果如何？
  \item 如果不将Segment类设为Point类的友元，应采取什么措施？为哪个类增加数据或函数成员？
\end{enumerate}
【程序】
\begin{lstlisting}[caption=*, label=prog1-1,basicstyle=\ttfamily,escapechar=`,frame=lines]
1、头文件shape.h
#include<iostream>
using namespace std;
class Segment;
class Point {
	friend class Segment;
protected:
	double m_x,m_y;
public:
	Point() { cout << "default constructor" << endl; };
	Point(double x, double y) :m_x(x), m_y(y) {
		cout << "parameter constructor" << endl;
	}
	Point(const Point &p) :m_x(p.m_x), m_y(p.m_y){//`\color{green}复制构造函数`
		cout << "copy constructor" << endl;
	}
	~Point() { cout << "destruct point" << endl; }
	Point& operator=(const Point &p) {                   //`\color{green}重载=`
		if (this != &p) {
			m_x = p.m_x;
			m_y = p.m_y;
		}
		cout << "point endow" << endl;
		return *this;
	}
};
class Circle :public Point {
protected:
	double m_radius;
public:
	Circle() { cout << "default construct circle" << endl; }
	Circle(const Point &p, double r) :Point(p), m_radius(r) {
		cout << "parameter construct circle" << endl;
	}
	Circle(const Circle &c) :Point(c), m_radius(c.m_radius){
		cout << "copy construct circle" << endl;
	}                                   //`\color{green}派生类复制构造函数`
	~Circle() { cout << "destruct circle" << endl; }
	Circle& operator=(const Circle &c) {//`\color{green}重载=`
		if (this != &c) {
			m_x = c.m_x;
			m_y = c.m_y;
			m_radius = c.m_radius;
		}
		cout << "circle endow" << endl;
		return *this;
	}
};
class Segment {
protected:
	Point p1;
	Point p2;
public:
	Segment() { cout << "default construct segment" << endl;}
	Segment(const Point&a, const Point &b) :p1(a), p2(b) {
		cout << "parameter construct segment" << endl;
	}
	Segment(const Segment &s) :p1(s.p1), p2(s.p2) {//`\color{green}复制构造函数`
		cout << "copy construct segment" << endl;
	}
	~Segment() { cout << "destruct segment" << endl; }//`\color{green}析构函数`
	Segment& operator=(Segment &s) {             //`\color{green}重载=`
		if (this != &s) {
			p1 = s.p1;
			p2 = s.p2;
		}
		cout << "segment endow" << endl;
		return *this;
	}
};
2、源文件
#include "shape.h"
int main() {
	{
    Point p1(2, 3), p2(3, 4), p3(p1), p4;
	Circle c1(p1, 3), c2(c1), c3;
	Segment s1(p1, p2), s2;
	s2 = s1;
	p4 = p2;
	c3 = c1;
    }
	return 0;
}
\end{lstlisting}
%#include <iostream>
%#include <cmath>
%using namespace std;
%const double PI=3.14159;
%class Point{
%    friend class Line;
%protected:
%    double m_x,m_y;
%public:
%    Point(){
%        m_x=0;
%        m_y=0;
%    }
%    Point(double x,double y){
%        m_x=x;
%        m_y=y;
%    }
%    double Area(){return 0;}
%    void Show(){
%        cout<<"x="<<m_x<<' '<<"y="<<m_y<<endl;
%    }
%};
%class Circle :public Point{
%    double m_radius;
%public:
%    Circle(){
%        m_x=0;
%        m_y=0;
%        m_radius=0;
%    }
%    Circle(double x,double y,double radius):Point(x,y){ //`\color{green}调用基类构造函数`
%        m_radius=radius;
%    }
%    Circle(Circle & cir):Point(cir){//`\color{green} 按赋值兼容规律cir可为Point实参`
%        m_radius=cir.m_radius;
%    }
%    Circle & operator=(Circle & cir){
%        this->Point::operator=(cir);//`\color{green} 在派生类中重载的拷贝赋值操作符有固定的标准格式`
%        m_radius=cir.m_radius;
%        return *this;
%    }
%    double Area(){
%        return PI*m_radius*m_radius;
%    }
%    void Show(){
%        //`\color{green}访问基类的数据成员`
%        cout<<"x="<<m_x<<' '<<"y="<<m_y<<' '<<"radius="<<m_radius
%        <<endl;
%    }
%};
%class Line{
%    Point m_start,m_end;//`\color{green}对象成员`
%public:
%    Line(){}//`\color{green}对象成员初始化`
%    Line(double x1,double y1,double x2,double y2):
%    m_start(x1,y1),m_end(x2,y2){}
%    double GetLength(){
%        return sqrt((m_start.m_x-m_end.m_x)*(m_start.m_x-m_end.m_x)
%        +(m_start.m_y-m_end.m_y)*(m_start.m_y-m_end.m_y));
%    }
%    double Area(){return 0;}
%    void Show(){
%        cout<<"start point:\n";
%        m_start.Show();
%        cout<<"end point:\n";
%        m_end.Show();
%    }
%};
%int main(){
%    Point pt(0,0);
%    Circle c11(100,100,10), c12(c11), c13;
%    Line ln1(0,0,100,100), ln2;
%    cout<<"点面积："<<pt.Area()<<endl;
%    pt.Show();
%    cout<<"c11 圆面积："<<c11.Area()<<endl;
%    c11.Show();
%    cout<<"c12 圆面积："<<c12.Area()<<endl;
%    c12.Show();
%    c13=c11;
%    cout<<"c13 圆面积："<<c13.Area()<<endl;
%    c13.Show();
%    cout<<"线面积："<<ln1.Area()<<'\t'<<"线长度："<<ln1.GetLength()
%    <<endl;
%    ln1.Show();
%    ln2.Show();
%    return 0;
%}
%【注意】
%\par 在Point类中,将Line类定义为友元，便于在Line类中访问；Point类的m\_x和m\_y定义为Pro-~tected 访问权限，便于派生类访问。注意派生类的构造函数中对基类数据成员的初始化方法（即 Circle(double x,double y,double radius):Point(x,y)），以及构造函数中对对象成员的初始化方法（即 Line(double x1,double y1,double x2,double y2) : m\_start(x1,y1),m\_end(x2,y2){ } ）。\\


\section*{实验9.2\quad 理解虚函数的作用}
\addcontentsline{toc}{section}{实验9.2\quad 理解虚函数的作用}
了解“单界面，多方法”的概念。现有称为figure的基类，存放了各二维对象（三角形、矩形两个类）的各维数据，set\_dim()设置数据，是标准成员函数。
area()为虚函数，因为计算各对象的面积的方法是不同的。\\
【程序】
\begin{lstlisting}[caption=*, label=prog1-1,basicstyle=\ttfamily,escapechar=`,frame=lines]
#include <iostream>
using namespace std;
class figure{
protected:
    double m_x,m_y;
public:
    void set_dim(double i,double j=0){
        m_x=i;
        m_y=j;
    }
    virtual void area(){//`\color{green}定义area()为虚函数`
    cout<<"本类没有面积计算。\n";}
};
class triangle :public figure{
public:
    void area() //`\color{green}派生类中重写area()函数`
    {cout<<"高和底为"<<m_x<<"和"<<m_y<<"的三角形面积为:"<<0.5*m_x*m_y<<endl;}
};
class square :public figure{
public:
    void area() //`\color{green}派生类中重写area()函数`
    {cout<<"长和宽分别为"<<m_x<<"和"<<m_y<<"的矩形的面积为:"<<m_x*m_y<<endl;}
};

int main(){
    figure *p;   //`\color{green}定义一个基类指针`
    triangle tri;
    square squ;
    p=&tri;      //`\color{green}基类指针指向派生类对象`
    p->set_dim(10.0,5.0);
    p->area();
    p=&squ;
    p->set_dim(10.0,5.0);
    p->area();
    return 0;
}
\end{lstlisting}
    %circle cir;
%    p=&cir;
%    p->set_dim(10.0);
%    p->area();
%class circle :public figure{
%public:
%    void area(){ //`\color{green}派生类中重写area()函数`
%    cout<<"半径为"<<m_x<<" 的圆的面积为："<<3.14159*m_x*m_x<<endl;}
%};
\noindent 【要求】
\begin{enumerate}
\item 建立工程，录入上述程序，调试运行并记录运行结果。
\item 修改上述程序，将virtual void area()中的virtual去掉，重新调试运行观察结果有何变化？为什么？
\item 修改上述程序入口函数，使其动态建立三角形、矩形2个对象，通过基类指针访问这2个对象，然后释放这2个对象。\\
\end{enumerate}

%\section*{实验9.3\quad 纯虚函数和抽象类的应用}
%\addcontentsline{toc}{section}{实验9.3\quad 纯虚函数和抽象类的应用}
%使用纯虚函数和抽象类对本章实验一进行改进。\\
%【要求】
%\par 先定义一个抽象类Element,提供显示、求面积等公共接口（虚函数），派生出Point、Line、\\
%Circle等图形元素类，并重新定义（override）这些虚函数，完成各自的任务。
%在这里，Element是抽象基类，它不能提供具体的显示操作，应将其成员函数定义为纯虚函数。只有采用指向基类的指针或对基类的引用进行调用，实现的才是动态绑定，
%完成运行时的多态性。\\

\section*{实验9.3\quad 继承与组合}
\addcontentsline{toc}{section}{实验9.3\quad 继承与组合}
类之间存在着继承与组合的关系，利用继承与组合的完成：点、线、圆、三角形、矩形、圆柱、长方体、圆锥类的定义。\\
\noindent 【提示】
\begin{enumerate}
\item 定义Shape基类和Point基类，其他形状类通过继承和组合得到；
\item 定容量容器类可以用一个vector实现，其元素为基类指针，基类指针指向派生类。
\end{enumerate}
\noindent 【要求】
\begin{enumerate}
\item 圆柱体、长方体、圆锥具有价值属性。
\item 以上类具有面积area，体积volume成员函数，且将重载operator$<$用于比较大小。（线：默认为长度大小；面：面积大小；体：体积比较）。
\item 设计一个具有一定容量的容器类：
     \begin{enumerate}
     \item 能容纳圆柱体、圆锥、长方体；
     \item 按照体积排序；
     \item 在给定物品当中选择一部分物品放入容器，使选中的物品总量不超过容器容量的前提下价值总和最大（不考虑物品的形状）。测试数据如下，最优方案中1代表对应物品被选择，0代表对应物品没有被选择。
     \end{enumerate}
\end{enumerate}
\begin{table}[!htbp]
\centering
\begin{tabular}{|c|c|c|c|}
\hline
\multicolumn{4}{|c|}{测试数据}\\
\hline
 容器容量&物品的容量&物品价值&最优方案\\
\hline
104&25,35,45,5,25,3,2,2&350,400,450,20,70,8,5,5&1,0,1,1,1,0,1,1\\
\hline
\end{tabular}
\end{table}

%\noindent 【程序】
%\begin{lstlisting}[caption=*, label=prog1-1,basicstyle=\ttfamily,escapechar=`,frame=lines]
%#include<iostream>
%#include<cmath>
%#define PI 3.14
%using namespace std;
%1、定义点类
%class Segment;//`\color{green}线段声明为点的友元`
%class Point {
%	friend class Segment;
%protected:
%	double m_x;
%	double m_y;
%public:
%	Point() {};
%	Point(double x,double y):m_x(x), m_y(y) {}
%	Point(const Point &p) :m_x(p.m_x), m_y(p.m_y) {}//`\color{green}复制构造函数`
%	~Point() {}
%	Point& operator=(Point &p) {//`\color{green}重载赋值运算符`
%		if (this != &p) {
%			m_x = p.m_x;
%			m_y = p.m_y;
%		}
%		return *this;
%	}
%	virtual double area() const { return 0; }`\color{green}点的面积声明为虚函数`
%	virtual double volume() const { return 0; }`\color{green}点的体积声明为虚函数`
%};
%2、定义线段类
%class Segment {
%protected:
%	Point p1;
%	Point p2;
%public:
%	Segment() {}
%	Segment(const Point&a, const Point &b) :p1(a), p2(b) {}
%	Segment(const Segment &s) :p1(s.p1), p2(s.p2) {}//`\color{green}复制构造`
%	~Segment() {}
%	double area() { return 0; }
%	double volume() { return 0; }
%	double length() {
%		return sqrt(pow(p1.m_x - p2.m_x, 2) + pow(p1.m_y - p2.m_y, 2));
%	}
%	Segment& operator=(Segment &s) {//`\color{green}重载赋值`
%		if (this != &s) {
%			p1 = s.p1;
%			p2 = s.p2;
%		}
%		return *this;
%	}
%	friend bool operator<(Segment &lhs,Segment &rhs){//`\color{green}重载小于号`
%		if (lhs.length() < rhs.length())
%			return 1;
%		else
%			return 0;
%	}
%};
%3、定义圆类
%class Circle :public Point {
%protected:
%	double m_radius;
%public:
%	Circle(){}
%	Circle(const Point &p,double r):Point(p), m_radius(r){}
%	Circle(const Circle &c):Point(c),m_radius(c.m_radius){}//`\color{green}派生类复制构造`
%	~Circle() {}
%	double area() { return PI * m_radius*m_radius; }
%	virtual double volume() {return 0;}//`\color{green}体积为虚函数`
%	Circle& operator=(const Circle &c) {
%		if (this != &c)
%		{
%			m_x = c.m_x;
%			m_y = c.m_y;
%			m_radius = c.m_radius;
%		}
%		return *this;
%	}
%	friend bool operator<(Circle &lhs,Circle &rhs) {
%		if (lhs.area() < rhs.area())
%			return 1;
%		else
%			return 0;
%	}
%};
%\end{lstlisting}
%\begin{table}[!htbp]
%\centering
%\begin{tabular}{|c|c|c|c|c|c|}
%\hline
%\multicolumn{2}{|c|}{Input1}&\multicolumn{2}{|c|}{Input2}&\multicolumn{2}{|c|}{Input3}\\
%\hline
%volume&value&volume&value&volume&value\\
%\hline
%100&5&200&8&300&10\\
%\hline
%77&92&79&83&95&89\\
%\hline
%22&22&58&14&75&59\\
%\hline
%29&87&86&54&23&19\\
%\hline
%50&46&11&79&73&43\\
%\hline
%99&90&28&72&22&72\\
%\hline
%Output& &Output& &Output& \\
%\hline
%\end{tabular}
%\end{table}
