\chapter{函数}
\thispagestyle{empty}
\setlength{\fboxrule}{0pt}\setlength{\fboxsep}{0cm}
\noindent\color{blueblack}\shadowbox{
\begin{tabular}{|p{13.8cm}|}\arrayrulecolor{darkblue}\hline
\rowcolor{darkblue} \hei\textcolor{white}{实验目的}\\\hline
\rowcolor{lightblue}~~~~~~~~\kai\textcolor{darkblue}{1. 掌握函数的定义及调用方法。}\\
\rowcolor{lightblue}~~~~~~~~\kai\textcolor{darkblue}{2. 掌握函数参数的传递（传值）、形参与实参的关系以及函数声明。}\\
\rowcolor{lightblue}~~~~~~~~\kai\textcolor{darkblue}{3. 掌握引用作为函数参数的方法。}\\
\rowcolor{lightblue}~~~~~~~~\kai\textcolor{darkblue}{4. 掌握指针或数组作为函数参数的函数定义及调用方法。}\\
\rowcolor{lightblue}~~~~~~~~\kai\textcolor{darkblue}{5. 了解内联函数、重载函数、带默认参数函数的定义及使用方法。}\\
\rowcolor{lightblue}~~~~~~~~\kai\textcolor{darkblue}{6. 掌握作用域的概念、变量的存储类型及它们之间的差别。}\\
\rowcolor{lightblue}~~~~~~~~\kai\textcolor{darkblue}{7. 掌握程序的多文件组织。}\\
\end{tabular}}\color{black}\\
\\
%\noindent\color{blueblack}\shadowbox{
%\begin{tabular}{|p{13.8cm}|}\arrayrulecolor{darkblue}\hline
%\rowcolor{darkblue} \hei\textcolor{white}{实验环境}\\\hline
%\rowcolor{lightblue}~~~~~~~~\kai\textcolor{darkblue}{1. Windows XP 以上操作系统。}\\
%\rowcolor{lightblue}~~~~~~~~\kai\textcolor{darkblue}{2. Visual Studio 2015 语言环境。}\\
%\rowcolor{lightblue}~~~~~~~~\kai\textcolor{darkblue}{3. 每人一台PC机。}\\
%\end{tabular}}\color{black}
\setlength{\fboxrule}{1pt}\setlength{\fboxsep}{4pt}
\section*{实验内容}

%给出迭代公式，sroot函数只给出声明，学生自己编写程序。
\section*{实验5.1\quad 用牛顿迭代法求平方根}
\addcontentsline{toc}{section}{实验5.1\quad 用迭代法求平方根的函数}
编写一个通用的求平方根的函数，参数（形参）为待求平方根的数，返回值为该数的平方根。由于平方数不能为负数，因此在主调函数中，需要判断输入数的正、负，为正则用该参数（实参）调用求平方根函数；为负则输出错误信息。\\
【提示】
\par 正数a的平方根牛顿迭代公式如下：\\
\[x_{n+1}=(x_n+\frac{a}{x_n})/2, x_1=a/2\]
平方根函数声明为：double sroot(double val);
%【程序】\\
%\begin{lstlisting}[caption=*, label=prog7-1,basicstyle=\ttfamily,escapechar=`,frame=lines]
%#include<iostream>
%#include<cmath>
%using namespace std;
%double sroot(double val);     //`\color{green}求平方根函数原型声明`
%int main() {
%    double root, value;
%    cout << "请输入一个数:\n ";
%    cin >> value;
%    if (a <= 0) cout << "输入错误!\n";
%    else {
%        root = sroot(value);
%        cout << " 数 " << value << " 的平方根为：" << root << endl;
%	}
%    return 0;
%}
%double sroot(double val) {
%    double temp = val / 2;
%    while (fabs((temp - val / temp) / 2) > 1e-7)
%        temp = (temp + val / temp) / 2;
%    return (temp);
%}
% \end{lstlisting}

\section*{实验5.2\quad 全局变量、局部变量和静态局部变量的应用}
\addcontentsline{toc}{section}{实验5.2\quad 全局变量、局部变量和静态局部变量的应用}
分析并写出下列程序的执行结果，然后输入计算机执行，比较分析结果与执行结果。如果两结果不相同请分析原因。\\
【程序】
\begin{lstlisting}[caption=*, label=prog9-3,basicstyle=\ttfamily,escapechar=`,frame=lines]
#include<iostream>
using namespace std;
int value1 = 300, value2 = 400, value3 = 500;
void funa(int value3) {
    static int value1 = 5;
    value1 += value3;
    cout << value1 << ' ' << value3 << '\n';
}
void funb(int value1) {
    value1 = value2;
    cout << value1 << '\n';
}
void func() {
    int value3=0;
    cout << value1 <<' '<< value2 <<' '<< value3 << '\n';
    ::value3 -= 100;
}
int main() {
    funa(value1);
    funb(value2);
    funa(value2);
    func();
    cout << value1 << ' ' << value2 << ' ' << value3 << '\n';
    return 0;
}
\end{lstlisting}

\section*{实验5.3\quad 设计一个简单的计算器程序}
\addcontentsline{toc}{section}{实验5.3\quad 设计一个简单的计算器程序}
从键盘输入“3+5”（代表表达式“3+5”），程序读入运算符和数据，然后根据运算符进行简单加、减、乘或除运算。要求能反复执行这一过程，直到用户输入“\#”符号为止。
函数原型如下：\\
double add(double ,double ); //加\\
double minus(double ,double ); //减\\
double multiply(double ,double ); //乘\\
double divide(double ,double ); //除\\


\section*{实验5.4\quad 字符串简单的“加密”和“解密”}
\addcontentsline{toc}{section}{实验5.4\quad 字符串简单的“加密”和“解密”}
按一定的规则可以将一个字符串经加密转换为一个新的串，例如加密的简单方法是当为'a'～'y'的小写字母时用后一个字母代替前一个字母，其中'z'变换为'a'，其他字符时不变。\\
例如： 原串为 This is a secret code!\\
加密后的串为 Tijt jt b tfdsfu dpef!
\par 编写一个程序对输入串加密，输出加密前和加密后的串，再将加密后的字符串解密输出。主函数如下，请编写加密函数和解密函数。\\
【程序】
\begin{lstlisting}[caption=*, label=prog1-1,basicstyle=\ttfamily,escapechar=`,frame=lines]
#include<iostream>
using namespace std;
void secret(char *data);
void desecret(char data[]);//`\color{green}传递数组参数的两种形式`
int main(){
    char st[]="This is a secret code!";
    cout<<st<<endl;
    secret(st);
    cout<<st<<endl;
    desecret(st);
    cout<<st<<endl;
    return 0;
}
\end{lstlisting}
%void secret(char* data) {
%    while (*data != '\0') {
%        if (*data >= 97 && *data <= 121) (*data)++;
%        else if (*data == 122)
%            *data = 'a';
%        data++;
%    }
%}
%void desecret(char data[]) {
%    while (*data != '\0') {
%        if (*data >= 98 && *data <= 122) (*data)--;
%        else if (*data == 97)
%            *data = 'z';
%        data++;
%    }
%}
【要求】
\begin{enumerate}
\item 将 secret(char *data)改为 secret(const char *data)，程序还能运行吗？为什么？
\item 仿造上例编写程序：设计一个带密钥的加密算法，例如密钥可以是一个常数，字符串加密的方法是将每个字符的ASCII码值加上该常数，然后对128求模。要求以密钥将加密的字符串加密输出，再以相同的密钥将加密字符串解密输出（注意功能字符的输出）。
\end{enumerate}

\section*{实验5.5\quad 求数组中最大元素}
\addcontentsline{toc}{section}{实验5.5\quad 求数组中最大元素}
求一个 3×4 矩阵中的最大元素，将求矩阵中的最大元素的过程定义为一个函数。函数的第一个参数是矩阵本身，第二个参数是第一维的大小。
这种方法的优点是使函数具有通用性，即无论一个矩阵的第一维是多大，只要该矩阵的第二维是 4 个元素，都可用该函数求最大元素；也可用该函数求一个矩阵开始几行中的最大元素。\\
【程序】
\begin{lstlisting}[caption=*, label=prog1-1,basicstyle=\ttfamily,escapechar=`,frame=lines]
#include <iostream>
using namespace std;
int max_value(int array[][4], int n);

int main(){
    int a[3][4]={{1,3,6,7},{2,4,6,8},{15,17,34,12}};
    cout<<max_value(a,3)<<'\n';
    return 0;
}

\end{lstlisting}

【要求】
\begin{enumerate}
\item 完成max\_value函数的定义；
\item 将 max\_value(int array[][4], int n)改为 max\_value(const int array[][4], int n)，程序还能运行吗？这样做有什么用？
\item 修改上述程序使其不仅可以求矩阵中的最大元素，还能求最大元素的行数和列数。\\
\end{enumerate}

\section*{实验5.6\quad 引用形参}
\addcontentsline{toc}{section}{实验5.6\quad 引用形参}
编写一个函数，其原型为：void index(int *a, int n, int key, int \&sub)，其功能是，在大小为 n 的数组 a 中，查找某个数 key， 若找到，将其下标存放在 sub 中，若没找到，将 -1 存放在sub中，在主调函数中通过判断值来判断数组中是否有该数。在这里，sub 是引用类型的参数，但起返回值的作用。\\
【程序】
\begin{lstlisting}[caption=*, label=prog1-1,basicstyle=\ttfamily,escapechar=`,frame=lines]
#include <iostream>
#include <stdlib.h>
using namespace std;
void index(int *array, int size, int key, int &sub);
int main() {
	int array2[25] = { 2,3,5,7,11,13,17,19,23,29,31,37,\
                       41,43,47,53,59,61,67,71,73,79,83,89,97 };
	int size = 25, sub, key;
	cin >> key;
	index(array2, size, key, sub);
	if (sub != -1)
		cout << "对应元素下标为:" << sub << endl;
	else
		cout << "未找到。" << endl;
	system("pause");
	return 0;
}
\end{lstlisting}
【要求】
\begin{enumerate}
\item 完成index函数的定义；
\item 修改主程序连续查找数字的循环语句，使程序能在输入特定数字后退出循环；
\item 将void index(int *array[], int size, int key, int \&sub) 改为void index(int array[], int size, int key, int sub)程序还能正确执行吗？试分析其结果并解释。
\end{enumerate}

\section*{实验5.7\quad 返回值引用}
\addcontentsline{toc}{section}{实验5.7\quad 返回值引用}
一个声明为返回引用的函数，既可以作为右值出现在赋值号的右边，也可以作为左值出现在赋值号的左边。下面是一个函数调用本身作为左值的例子。
\begin{lstlisting}[caption=*, label=prog1-1,basicstyle=\ttfamily,escapechar=`,frame=lines]
#include<iostream>
#include <stdlib.h>
using namespace std;
int& index(int array[], int num) {//`\color{green}定义索引函数`
	return array[num];
}
int main() {
	int Array[] = { 2,4,6,8,10 };
	index(Array,3) = 16;
	for (int i = 0; i<5; i++)
		cout << index(Array,i) << ' ';
	cout << endl;
	system("pause");
	return 0;
}
\end{lstlisting}
【要求】
\par 修改程序使用非返回引用的函数实现上述功能，试分析两者之间的区别。\\

\section*{实验5.8\quad 函数的重载}
\addcontentsline{toc}{section}{实验5.8\quad 函数的重载}
重载函数允许不同的函数使用相同的名字，这使得完成类似的任务时可以使用相同的函数名。
编写几个计算面积的函数，分别计算圆、矩形和三角形的面积， 计算周长为1的圆，及其内接正方形、内接等边三角形的面积。\\
【提示】
\begin{enumerate}
  \item 圆面积，参数为半径：double area(double radius=0)，默认参数为0，表示点面积 ；
  \item 矩形面积，参数为长和宽 ：double area(double a, double b)；
  \item 三角形面积，参数为三边长，double area(double a, double b, double c)。
\end{enumerate}
%【程序】
% \begin{lstlisting}[caption=*, label=prog9-1,basicstyle=\ttfamily,escapechar=`,frame=lines]
%#include<iostream>
%#include<cmath>
%using namespace std;
%const double PI = 3.14159;
%double area(double radius = 0);
%double area(double length, double height);
%double area(double bottom, double top, double height);
%double area(double edge1, double edge2, double edge3, int);
%int main() {
%    cout << "点的面积为 " << area() << '\n';
%    cout << "矩形的面积为 " << area(1,1) << '\n';
%    cout << "圆的面积为 " << area(0.5) << '\n';
%    cout << "梯形的面积为 " << area(1,0.5,1) << '\n';
%    cout << "三角形的面积为 " << area(1,sqrt(1+0.5*0.5),
%    sqrt(1 + 0.5*0.5),0) << '\n';
%    return 0;
%}
%double area(double radius) {//`\color{green}带默认参数的函数`
%    return PI*radius*radius;
%}
%double area(double length, double height) {
%    return length*height;
%}
%double area(double bottom, double top, double height) {
%    return (0.5*(bottom+top)*height);
%}
%double area(double edge1, double edge2, double edge3, int) {
%    double s = 0.5*(edge1+edge2+edge3);
%    return sqrt(s*(s-edge1)*(s-edge2)*(s-edge3));
%}
%\end{lstlisting}
【要求】
\begin{enumerate}
\item 编译运行程序，并记录运行结果，注意函数调用时，实参与形参之间的关系（包括类型、个数）。
\item 若将计算矩形面积的函数原型改为 double area(double length=0, double height=0)重新编译运行情况会怎样？为什么？
\item 若将计算三角形面积的函数原型改为 double area(double edge1, double edge2，double edge3); 程序还能正确运行吗？为什么？
\item 若将计算三角形面积的函数原型改为 double area(double edge1, double edge2，double edge3=0，int); 程序还能正确运行吗？为什么？
\item 将本实验以多文件方式进行组织，在area.h 中声明各个area( )函数原型，在area.cpp中定义函数，然后在Exp5\_8.cpp中包含area.h，并定义main( )函数并执行。\\
\end{enumerate}

\section*{实验5.9\quad 用递归函数实现勒让德多项式}
\addcontentsline{toc}{section}{实验5.9\quad 用递归函数实现勒让德多项式}
勒让德多项式的分段函数形式如下：\\
\begin{equation}
P_{n}(x)=
\begin{cases}
1& \text{n=0}\\
x& \text{n=1}\\
\displaystyle\frac{(2n-1)P_{n-1}(x)-(n-1)P_{n-2}(x)}{n} &\text{n$>$1}
\end{cases}
\end{equation}
%$$P_{n}(x)=\frac{1}{2^{n}n!}\cdot\frac{\mathrm{d}^{n}}{\mathrm{d}x^{n}}[(x^{2}-1)^{n}]$$
【要求】
\begin{enumerate}
  \item 利用递归函数求出勒让德多项式；
  \item 在主函数中输入$P_{4}(1.5)$，求值。
\end{enumerate}

